const { onCall, onRequest, HttpsError } = require('firebase-functions/v2/https');
const { initializeApp } = require('firebase-admin/app');
const { getAuth } = require('firebase-admin/auth');
const { getFirestore } = require('firebase-admin/firestore');
const { getStorage } = require('firebase-admin/storage');

// Inicializar Firebase Admin
initializeApp();

// Importar funciones de notificaciones (Email + Telegram)
// TODO: Implementar nuevas funciones de notificaciones

/**
 * Cloud Function para eliminar usuario completo (Auth + Firestore)
 * Solo disponible para administradores
 */
exports.deleteUserComplete = onCall(async (request) => {
  const { auth, data } = request;

  // Verificar autenticaci√≥n
  if (!auth) {
    throw new HttpsError('unauthenticated', 'Usuario no autenticado');
  }

  const { userEmail, userId } = data;

  if (!userEmail || !userId) {
    throw new HttpsError('invalid-argument', 'Email y ID de usuario requeridos');
  }

  try {
    const db = getFirestore();
    const adminAuth = getAuth();

    // 1. Verificar que el usuario que llama es administrador
    const callerDoc = await db.collection('users')
      .where('authUid', '==', auth.uid)
      .limit(1)
      .get();

    if (callerDoc.empty) {
      throw new HttpsError('permission-denied', 'Usuario no encontrado en sistema');
    }

    const callerData = callerDoc.docs[0].data();
    if (callerData.role !== 'ADMIN') {
      throw new HttpsError('permission-denied', 'Solo administradores pueden eliminar usuarios');
    }

    // 2. Obtener datos del usuario a eliminar
    const userDoc = await db.collection('users').doc(userId).get();
    
    if (!userDoc.exists) {
      throw new HttpsError('not-found', 'Usuario no encontrado');
    }

    const userData = userDoc.data();

    // 3. Verificar que no es el √∫ltimo admin
    if (userData.role === 'ADMIN') {
      const adminQuery = await db.collection('users')
        .where('role', '==', 'ADMIN')
        .where('isActive', '!=', false)
        .get();
      
      if (adminQuery.size <= 1) {
        throw new HttpsError('failed-precondition', 'No puedes eliminar el √∫ltimo administrador');
      }
    }

    // 4. Prevenir auto-eliminaci√≥n
    if (userData.email === callerData.email) {
      throw new HttpsError('failed-precondition', 'No puedes eliminar tu propio usuario');
    }

    // 5. Eliminar de Firebase Auth si tiene authUid
    let deletedFromAuth = false;
    if (userData.authUid) {
      try {
        await adminAuth.deleteUser(userData.authUid);
        deletedFromAuth = true;
        console.log('‚úÖ Usuario eliminado de Firebase Auth:', userData.authUid);
      } catch (authError) {
        console.warn('‚ö†Ô∏è Error eliminando de Auth:', authError.code, authError.message);
        // Si no existe en Auth, no es error cr√≠tico
        if (authError.code === 'auth/user-not-found') {
          deletedFromAuth = true; // Ya no existe, considerarlo como eliminado
        }
      }
    } else {
      // Si no tiene authUid, buscar por email en Auth
      try {
        const userRecord = await adminAuth.getUserByEmail(userData.email);
        await adminAuth.deleteUser(userRecord.uid);
        deletedFromAuth = true;
        console.log('‚úÖ Usuario eliminado de Firebase Auth (por email):', userRecord.uid);
      } catch (authError) {
        console.warn('‚ö†Ô∏è Usuario no encontrado en Auth o error:', authError.code, authError.message);
        if (authError.code === 'auth/user-not-found') {
          deletedFromAuth = true; // Ya no existe en Auth
        }
      }
    }

    // 6. Eliminar de Firestore
    await db.collection('users').doc(userId).delete();
    console.log('‚úÖ Usuario eliminado de Firestore:', userId);

    // 7. Log de auditor√≠a
    await db.collection('audit_logs').add({
      action: 'DELETE_USER',
      targetUser: userData.email,
      performedBy: callerData.email,
      performedByUid: auth.uid,
      timestamp: new Date(),
      details: {
        deletedUser: {
          email: userData.email,
          role: userData.role,
          displayName: userData.displayName
        }
      }
    });

    return {
      success: true,
      message: `Usuario ${userData.email} eliminado completamente`,
      deletedFromAuth: deletedFromAuth,
      deletedFromFirestore: true
    };

  } catch (error) {
    console.error('‚ùå Error en deleteUserComplete:', error);
    console.error('Error details:', {
      code: error.code,
      message: error.message,
      stack: error.stack
    });
    
    if (error instanceof HttpsError) {
      throw error;
    }
    
    // Proporcionar m√°s detalles del error
    let errorMessage = 'Error interno desconocido';
    if (error.message) {
      errorMessage = error.message;
    }
    
    throw new HttpsError('internal', `Error interno: ${errorMessage}`);
  }
});

/**
 * HTTP proxy para descargar archivos de Storage evitando CORS en el cliente.
 * Uso: GET /storageProxy?path=<ruta en el bucket>
 */
exports.storageProxy = onRequest(async (req, res) => {
  // Permitir CORS b√°sico
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.status(204).send('');
  }

  try {
    const path = req.query.path;
    if (!path || typeof path !== 'string') {
      return res.status(400).json({ error: 'Missing required query param: path' });
    }

    const bucket = getStorage().bucket();
    const file = bucket.file(path);
    const [exists] = await file.exists();
    if (!exists) {
      return res.status(404).json({ error: 'File not found' });
    }

    const [metadata] = await file.getMetadata();
    res.setHeader('Content-Type', metadata.contentType || 'application/octet-stream');
    res.setHeader('Cache-Control', 'private, max-age=0, no-cache');

    file.createReadStream()
      .on('error', (err) => {
        console.error('storageProxy stream error:', err);
        res.status(500).json({ error: 'Stream error', details: err.message });
      })
      .pipe(res);
  } catch (err) {
    console.error('storageProxy error:', err);
    res.status(500).json({ error: 'Internal error', details: err.message });
  }
});

/**
 * Webhook para Telegram Bot
 * Responde autom√°ticamente al comando /start con el Chat ID del usuario
 */
exports.telegramWebhook = onRequest(async (req, res) => {
  // Solo aceptar POST requests
  if (req.method !== 'POST') {
    return res.status(200).send('OK');
  }

  try {
    const update = req.body;
    
    // Verificar si hay un mensaje
    if (!update.message) {
      return res.status(200).send('OK');
    }

    const message = update.message;
    const chatId = message.chat.id;
    const text = message.text;
    const firstName = message.from.first_name || 'Usuario';
    const username = message.from.username || '';

    // Responder al comando /start
    if (text && text.toLowerCase() === '/start') {
      // Usar variable de entorno directamente
      const BOT_TOKEN = process.env.VITE_TELEGRAM_BOT_TOKEN || 
                        process.env.TELEGRAM_BOT_TOKEN ||
                        '8430298503:AAEVPOGrIp5_UdUNGXSy3AD9rI8mS2OKipQ'; // Fallback
      
      if (!BOT_TOKEN) {
        console.error('‚ùå TELEGRAM_BOT_TOKEN no configurado');
        return res.status(200).send('OK');
      }

      const responseMessage = 
        `üéâ ¬°Hola ${firstName}! üëã\n\n` +
        `Tu bot de DR Group est√° listo para enviarte notificaciones.\n\n` +
        `üì± <b>Tu Chat ID es:</b> <code>${chatId}</code>\n\n` +
        `‚úÖ Copia este n√∫mero y p√©galo en la configuraci√≥n de notificaciones del dashboard.\n\n` +
        `üí° <b>Instrucciones:</b>\n` +
        `1. Ve a la p√°gina de Usuarios en el dashboard\n` +
        `2. Haz clic en el bot√≥n de configuraci√≥n (‚öôÔ∏è)\n` +
        `3. Activa Telegram\n` +
        `4. Pega tu Chat ID: <code>${chatId}</code>\n` +
        `5. Guarda y prueba la notificaci√≥n\n\n` +
        `ü§ñ <i>DR Group Bot</i>`;

      // Enviar respuesta
      const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: chatId,
          text: responseMessage,
          parse_mode: 'HTML'
        })
      });

      const data = await response.json();
      
      if (data.ok) {
        console.log(`‚úÖ Respuesta enviada a ${firstName} (${username}) - Chat ID: ${chatId}`);
      } else {
        console.error('‚ùå Error enviando mensaje:', data);
      }
    }

    return res.status(200).send('OK');
  } catch (error) {
    console.error('‚ùå Error en webhook:', error);
    return res.status(200).send('OK'); // Siempre retornar 200 para Telegram
  }
});
